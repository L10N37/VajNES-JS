// Program at CPU $8000 (PRG offset 0)
prgRom[0x0000] = 0x78;                         // SEI
prgRom[0x0001] = 0xD8;                         // CLD
prgRom[0x0002] = 0xA2; prgRom[0x0003] = 0x40;  // LDX #$40
prgRom[0x0004] = 0x8E; prgRom[0x0005] = 0x17; prgRom[0x0006] = 0x40; // STX $4017
prgRom[0x0007] = 0xA2; prgRom[0x0008] = 0xFF;  // LDX #$FF
prgRom[0x0009] = 0x9A;                         // TXS
prgRom[0x000A] = 0xE8;                         // INX
prgRom[0x000B] = 0x8E; prgRom[0x000C] = 0x00; prgRom[0x000D] = 0x20; // STX $2000
prgRom[0x000E] = 0x8E; prgRom[0x000F] = 0x01; prgRom[0x0010] = 0x20; // STX $2001
prgRom[0x0011] = 0x8E; prgRom[0x0012] = 0x10; prgRom[0x0013] = 0x40; // STX $4010

// palette: set universal background color $3C
prgRom[0x0014] = 0xAD; prgRom[0x0015] = 0x02; prgRom[0x0016] = 0x20; // LDA $2002
prgRom[0x0017] = 0xA9; prgRom[0x0018] = 0x3F;
prgRom[0x0019] = 0x8D; prgRom[0x001A] = 0x06; prgRom[0x001B] = 0x20;
prgRom[0x001C] = 0xA9; prgRom[0x001D] = 0x00;
prgRom[0x001E] = 0x8D; prgRom[0x001F] = 0x06; prgRom[0x0020] = 0x20;
prgRom[0x0021] = 0xA9; prgRom[0x0022] = 0x3C;
prgRom[0x0023] = 0x8D; prgRom[0x0024] = 0x07; prgRom[0x0025] = 0x20;

// nametable fill: 32 tiles across first row
prgRom[0x0026] = 0xAD; prgRom[0x0027] = 0x02; prgRom[0x0028] = 0x20; // LDA $2002
prgRom[0x0029] = 0xA9; prgRom[0x002A] = 0x20;
prgRom[0x002B] = 0x8D; prgRom[0x002C] = 0x06; prgRom[0x002D] = 0x20;
prgRom[0x002E] = 0xA9; prgRom[0x002F] = 0x00;
prgRom[0x0030] = 0x8D; prgRom[0x0031] = 0x06; prgRom[0x0032] = 0x20;

prgRom[0x0033] = 0xA2; prgRom[0x0034] = 0x20; // LDX #$20
// loop
prgRom[0x0035] = 0x8A;                         // TXA
prgRom[0x0036] = 0x49; prgRom[0x0037] = 0x20;  // EOR #$20 (count 0..31)
prgRom[0x0038] = 0x8D; prgRom[0x0039] = 0x07; prgRom[0x003A] = 0x20; // STA $2007
prgRom[0x003B] = 0xCA;                         // DEX
prgRom[0x003C] = 0xD0; prgRom[0x003D] = 0xF6;  // BNE loop

// enable background
prgRom[0x003E] = 0xA9; prgRom[0x003F] = 0x08;
prgRom[0x0040] = 0x8D; prgRom[0x0041] = 0x01; prgRom[0x0042] = 0x20;

// forever loop
prgRom[0x0043] = 0x4C; prgRom[0x0044] = 0x43; prgRom[0x0045] = 0x80;

// vectors at end of PRG-ROM
prgRom[prgRom.length - 6] = 0x00; // NMI low
prgRom[prgRom.length - 5] = 0x80;
prgRom[prgRom.length - 4] = 0x00; // RESET low
prgRom[prgRom.length - 3] = 0x80;
prgRom[prgRom.length - 2] = 0x00; // IRQ low
prgRom[prgRom.length - 1] = 0x80;


// Clear CHR
for (let i = 0; i < 0x2000; i++) CHR_ROM[i] = 0x00;

// Each tile = 16 bytes
function fillTile(tileIndex, plane0, plane1) {
  const base = tileIndex * 16;
  for (let row = 0; row < 8; row++) {
    CHR_ROM[base + row]     = plane0[row];
    CHR_ROM[base + 8 + row] = plane1[row];
  }
}

// Tile 0 = blank
fillTile(0, Array(8).fill(0x00), Array(8).fill(0x00));

// Tile 1 = solid color-1
fillTile(1, Array(8).fill(0xFF), Array(8).fill(0x00));

// Tile 2 = solid color-2
fillTile(2, Array(8).fill(0x00), Array(8).fill(0xFF));

// Tile 3 = checkerboard
fillTile(3,
  [0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55],
  Array(8).fill(0x00)
);

// Tile 4 = vertical stripes
fillTile(4,
  Array(8).fill(0xF0),
  Array(8).fill(0x00)
);

// Tile 5 = horizontal stripes
fillTile(5,
  [0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x00],
  Array(8).fill(0x00)
);

// Fill rest (tiles 6..255) with alternating row patterns
for (let t = 6; t < 256; t++) {
  const pat = (t & 1) ? 0x0F : 0xF0;
  fillTile(t, Array(8).fill(pat), Array(8).fill(0x00));
}
